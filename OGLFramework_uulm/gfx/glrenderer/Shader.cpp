/**
 * @file   Shader.cpp
 * @author Sebastian Maisch <sebastian.maisch@googlemail.com>
 * @date   15. Januar 2014
 *
 * @brief  Contains the implementation of Shader.
 */

#include "Shader.h"
#include "app/ApplicationBase.h"

#include <fstream>
#include <boost/algorithm/string/predicate.hpp>

/**
 * Constructor.
 * @param shader the name of the shader the error occurred in
 * @param errors the error string opengl returned
 */
shader_compiler_error::shader_compiler_error(const std::string& shader, const std::string& errors) :
shr(shader),
errs(errors)
{
}

/** Returns information about the exception */
const char* shader_compiler_error::what() const
{
    std::string result = "Shader " + shr + " compilation failed!\n";
    result += "Compiler errors:\n" + errs;
    return result.c_str();
}

/**
 * Constructor.
 * @param shaderFilename the shaders file name
 */
Shader::Shader(const std::string& shaderFilename, ApplicationBase* app) :
Resource(shaderFilename, app),
shader(0),
type(GL_VERTEX_SHADER),
strType("vertex")
{
    if (boost::ends_with(shaderFilename, ".fp")) {
        type = GL_FRAGMENT_SHADER;
        strType = "fragment";
    } else if (boost::ends_with(shaderFilename, ".gp")) {
        type = GL_GEOMETRY_SHADER;
        strType = "geometry";
    } else if (boost::ends_with(shaderFilename, ".tcp")) {
        type = GL_TESS_CONTROL_SHADER;
        strType = "tesselation control";
    } else if (boost::ends_with(shaderFilename, ".tep")) {
        type = GL_TESS_EVALUATION_SHADER;
        strType = "tesselation evaluation";
    } else if (boost::ends_with(shaderFilename, ".cp")) {
        type = GL_COMPUTE_SHADER;
        strType = "compute";
    }
}

Shader::Shader(Shader&& orig) :
Resource(std::move(orig)),
shader(orig.shader),
type(orig.type),
strType(std::move(orig.strType))
{
    orig.shader = 0;
    orig.type = GL_VERTEX_SHADER;
}

Shader& Shader::operator =(Shader&& orig)
{
    Resource* tRes = this;
    *tRes = static_cast<Resource&&> (std::move(orig));
    if (this != &orig) {
        shader = orig.shader;
        type = orig.type;
        strType = std::move(orig.strType);
        orig.shader = 0;
        orig.type = GL_VERTEX_SHADER;
    }
    return *this;
}

/** Destructor. */
Shader::~Shader()
{
    if (IsLoaded()) UnloadLocal();
}

void Shader::Load()
{
    shader = CompileShader(application->GetConfig().resourceBase + "/" + id, type, strType);
    Resource::Load();
}

/**
 * Reset the shader to a new name generated by RecompileShader before.
 * This is used to make sure an old shader is not lost if linking shaders to a program fails.
 * @param newShader the recompiled shader
 */
void Shader::ResetShader(GLuint newShader)
{
    Unload();
    shader = newShader;
    Resource::Load();
}

/**
 * Recompiles the shader.
 * The returned shader name should be set with ResetShader later after linking the program succeeded.
 * If the linking failed the program needs to delete the new shader object.
 * @return the new shader object name
 */
GLuint Shader::RecompileShader()
{
    return CompileShader(application->GetConfig().resourceBase + "/" + id, type, strType);
}

void Shader::UnloadLocal()
{
    if (this->shader != 0) {
        OGL_CALL(glDeleteShader, shader);
        shader = 0;
    }
}

void Shader::Unload()
{
    UnloadLocal();
    Resource::Unload();
}

/**
 * Loads a shader from file and compiles it.
 * @param filename the shaders file name
 * @param type the shaders type
 * @param strType the shaders type as string
 * @return the compiled shader if successful
 */
GLuint Shader::CompileShader(const std::string& filename, GLenum type, const std::string& strType)
{
    std::ifstream file(filename.c_str(), std::ifstream::in);
    std::string line;
    std::stringstream content;
    while (file.good()) {
        std::getline(file, line);
        content << line << std::endl;
    }
    file.close();
    std::string shaderText = content.str();
    GLuint shader = OGL_CALL(glCreateShader, type);
    if (shader == 0) {
        LOG(ERROR) << L"Could not create shader!";
        throw std::runtime_error("Could not create shader!");
    }
    const char* shaderTextArray = shaderText.c_str();
    int shaderLength = static_cast<int>(shaderText.length());
    OGL_CALL(glShaderSource, shader, 1, &shaderTextArray, &shaderLength);
    OGL_CALL(glCompileShader, shader);

    GLint status;
    OGL_CALL(glGetShaderiv, shader, GL_COMPILE_STATUS, &status);
    if (status == GL_FALSE) {
        GLint infoLogLength;
        OGL_CALL(glGetShaderiv, shader, GL_INFO_LOG_LENGTH, &infoLogLength);

        GLchar *strInfoLog = new GLchar[infoLogLength + 1];
        OGL_CALL(glGetShaderInfoLog, shader, infoLogLength, NULL, strInfoLog);

        LOG(ERROR) << L"Compile failure in " << strType << L" shader ("
                << filename.c_str() << "): " << std::endl << strInfoLog;
        std::string infoLog = strInfoLog;
        delete[] strInfoLog;
        OGL_CALL(glDeleteShader, shader);
        throw shader_compiler_error(filename, infoLog);
    }
    return shader;
}
